// Generated by CoffeeScript 1.6.3
(function() {
  var Bebop, bebop, isBrowser, root;
  isBrowser = (typeof window === "undefined" ? false : true);
  root = (isBrowser ? window : global);
  Bebop = (function() {
    function Bebop() {
      var hostname, port, protocol;
      protocol = (window.location.protocol === "http:" ? "ws://" : "wss://");
      hostname = window.location.hostname;
      port = window.location.port;
      this.address = protocol + hostname + ":" + port + "/_bebop";
    }

    Bebop.prototype.oncomplete = function(msg) {
      var e, obj;
      try {
        obj = eval_.call(root, msg);
        return this.send({
          type: "complete",
          result: this.dir(obj)
        });
      } catch (_error) {
        e = _error;
        return this.send({
          type: "complete",
          result: []
        });
      }
    };

    Bebop.prototype.oneval = function(msg) {
      var e, error, res;
      try {
        res = eval_.call(root, msg);
        return this.send({
          type: "eval",
          result: res
        });
      } catch (_error) {
        e = _error;
        error = {
          error: e.message,
          stack: this.stacktrace(e)
        };
        return this.send({
          type: "eval",
          result: error
        });
      }
    };

    Bebop.prototype.onmodified = function(msg) {
      var node;
      if (isBrowser) {
        node = this.findNode(msg);
        if (node) {
          return this.reload(node);
        } else {
          return location.reload(true);
        }
      }
    };

    Bebop.prototype.onopen = function() {
      return this.log("Connected to Bebop");
    };

    Bebop.prototype.onclose = function() {
      return this.log("Connection to Bebop closed");
    };

    Bebop.prototype.reload = function(node) {
      var link;
      if (node._resource.ext === "js") {
        node.parentNode.removeChild(node);
        return this.load(node._resource);
      }
      link = node._resource.tag.link;
      node[link] = this.urlRandomize(node[link]);
      return this.log("Reloaded " + node[link]);
    };

    Bebop.prototype.load = function(resource) {
      var node;
      node = document.createElement(resource.tag.name);
      node[resource.tag.link] = resource.url;
      node.type = resource.tag.type;
      document.getElementsByTagName("head")[0].appendChild(node);
      return this.log("Loaded " + node[resource.tag.link]);
    };

    Bebop.prototype.dir = function(object) {
      var i, properties, property, seen, valid;
      valid = function(name) {
        var i, invalid;
        invalid = ["arguments", "caller", "name", "length", "prototype"];
        for (i in invalid) {
          if (invalid[i] === name) {
            return false;
          }
        }
        return true;
      };
      property = void 0;
      properties = [];
      seen = {};
      if (Object.getOwnPropertyNames !== "undefined") {
        properties = Object.getOwnPropertyNames(object);
        for (property in object) {
          properties.push(property);
        }
        properties = properties.filter(function(name) {
          return valid(name);
        });
        i = 0;
        while (i < properties.length) {
          seen[properties[i]] = "";
          i++;
        }
        return Object.keys(seen);
      } else {
        for (property in object) {
          properties.push(property);
        }
      }
      return properties;
    };

    Bebop.prototype.dump = function(object) {
      var derez, funcname, objects, paths, that;
      funcname = void 0;
      objects = [];
      paths = [];
      that = this;
      return (derez = function(value, path) {
        var e, i, name, nu, properties;
        i = void 0;
        name = void 0;
        nu = void 0;
        properties = void 0;
        switch (typeof value) {
          case "object":
            if (!value) {
              return null;
            }
            i = 0;
            while (i < objects.length) {
              if (objects[i] === value) {
                return {
                  $ref: paths[i]
                };
              }
              i += 1;
            }
            objects.push(value);
            paths.push(path);
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              nu = [];
              i = 0;
              while (i < value.length) {
                nu[i] = derez(value[i], path + "[" + i + "]");
                i += 1;
              }
            } else {
              nu = {};
              properties = that.dir(value);
              for (i in properties) {
                name = properties[i];
                if (typeof value[name] === "function") {
                  funcname = (value[name].toString().split(")")[0] + ")").replace(" " + name, "");
                  if (that.dir(value[name]).length < 1) {
                    nu[name] = funcname;
                  } else {
                    try {
                      nu[name] = derez(value[name], path + "[" + JSON.stringify(name) + "]");
                    } catch (_error) {}
                  }
                } else {
                  try {
                    nu[name] = derez(value[name], path + "[" + JSON.stringify(name) + "]");
                  } catch (_error) {}
                }
              }
            }
            return nu;
          case "number":
          case "string":
          case "boolean":
            return value;
          case "function":
            try {
              properties = that.dir(value);
              objects.push(value);
              paths.push(path);
              nu = {};
              for (i in properties) {
                name = properties[i];
                if (typeof value[name] === "function") {
                  funcname = (value[name].toString().split(")")[0] + ")").replace(" " + name, "");
                  if (that.dir(value[name]).length < 1) {
                    nu[name] = funcname;
                  } else {
                    nu[name] = derez(value[name], path + "[" + JSON.stringify(name) + "]");
                  }
                } else {
                  nu[name] = derez(value[name], path + "[" + JSON.stringify(name) + "]");
                }
              }
              return nu;
            } catch (_error) {
              e = _error;
              return nu;
            }
        }
      })(object, "$");
    };

    Bebop.prototype.log = function() {
      if (root.console) {
        return console.log.apply(console, arguments_);
      }
    };

    Bebop.prototype.connect = function() {
      var WebSocket, err, that, ws;
      that = this;
      ws = void 0;
      WebSocket = root.WebSocket || root.MozWebSocket;
      if (!WebSocket) {
        if (isBrowser) {
          this.webSocketFallback();
        } else {
          WebSocket = require("ws");
        }
      }
      try {
        ws = new WebSocket(that.address);
      } catch (_error) {
        err = _error;
        return root.setTimeout(that.connect, 500);
      }
      ws.onopen = function() {
        var identifier;
        that.onopen();
        identifier = void 0;
        if (isBrowser) {
          identifier = location.href + " - " + navigator.userAgent;
        } else {
          identifier = process.argv[1] + " - node";
        }
        return this.send(JSON.stringify({
          type: "connected",
          identifier: identifier
        }));
      };
      ws.onclose = function() {
        return setTimeout((function() {
          return that.connect();
        }), 500);
      };
      ws.onerror = function() {
        return setTimeout((function() {
          return that.connect();
        }), 500);
      };
      ws.onmessage = function(message) {
        that.log(message);
        message = JSON.parse(message.data);
        that.log(message);
        switch (message.type) {
          case "complete":
            return that.oncomplete(data.name);
          case "eval":
            return that.oneval(data.code);
          case "modified":
            return that.onmodified(data.filename);
          case "reload":
            return setTimeout((function() {
              return location.reload(true);
            }), 2000);
        }
      };
      return this.ws = ws;
    };

    Bebop.prototype.send = function(msg) {
      return this.ws.send(JSON.stringify(msg));
    };

    Bebop.prototype.webSocketFallback = function() {
      var urls;
      root.WEB_SOCKET_SWF_LOCATION = "https://github.com/gimite/web-socket-js/blob/master/WebSocketMain.swf?raw=true";
      urls = ["https://github.com/gimite/web-socket-js/blob/master/swfobject.js?raw=true", "https://github.com/gimite/web-socket-js/blob/master/web_socket.js?raw=true"];
      this.load(this.urlParse(urls[0]));
      return this.load(this.urlParse(urls[1]));
    };

    Bebop.prototype.tags = {
      js: {
        link: "src",
        name: "script",
        type: "text/javascript"
      },
      css: {
        link: "href",
        name: "link",
        type: "text/css"
      }
    };

    Bebop.prototype.findNode = function(url) {
      var e, i, node, nodes, resource;
      if (url === "") {
        return false;
      }
      node = void 0;
      nodes = void 0;
      resource = void 0;
      try {
        resource = this.urlParse(url);
        nodes = document.getElementsByTagName(resource.tag.name);
        i = 0;
        while (i < nodes.length) {
          node = nodes[i];
          if (node[resource.tag.link].indexOf(resource.filename) !== -1) {
            node._resource = resource;
            return node;
          }
          i++;
        }
      } catch (_error) {
        e = _error;
        return false;
      }
      return false;
    };

    Bebop.prototype.urlRandomize = function(url) {
      url = url.replace(/[?&]bebop=\w+/, "");
      url += (url.indexOf("?") === -1 ? "?" : "&");
      return url + "bebop=" + (((1 + Math.random()) * 0x100000) | 0).toString(16);
    };

    Bebop.prototype.urlParse = function(url) {
      var ext, filename, path, resource;
      ext = void 0;
      filename = void 0;
      path = void 0;
      resource = void 0;
      path = url.split("/");
      filename = path.pop();
      ext = filename.split(".")[1];
      resource = {
        ext: ext,
        filename: filename,
        path: path,
        tag: this.tags[ext],
        url: url
      };
      return resource;
    };

    Bebop.prototype.exportGlobals = function() {
      var globals, key, original, that, _results;
      that = this;
      globals = {
        bebop: that,
        dir: function(obj) {
          return that.dir(obj);
        },
        dump: function(obj) {
          return that.dump(obj);
        }
      };
      _results = [];
      for (key in globals) {
        if (typeof root[key] !== "undefined") {
          original = root[key];
          root[key] = globals[key];
          _results.push(root[key]._original = original);
        } else {
          _results.push(root[key] = globals[key]);
        }
      }
      return _results;
    };

    Bebop.prototype.stacktrace = function(e) {
      var method;
      method = {
        chrome: function(e) {
          var stack;
          stack = (e.stack + "\n").replace(/^\S[^\(]+?[\n$]/g, "").replace(/^\s+(at eval )?at\s+/g, "").replace(/^([^\(]+?)([\n$])/g, "{anonymous}()@$1$2").replace(/^Object.<anonymous>\s*\(([^\)]+)\)/g, "{anonymous}()@$1").split("\n");
          stack.pop();
          return stack;
        },
        firefox: function(e) {
          return e.stack.replace(/(?:\n@:0)?\s+$/m, "").replace(/^\(/g, "{anonymous}(").split("\n");
        },
        other: function(curr) {
          var ANON, args, fn, fnRE, maxStackSize, stack;
          ANON = "{anonymous}";
          fnRE = /function\s*([\w\-$]+)?\s*\(/i;
          stack = [];
          fn = void 0;
          args = void 0;
          maxStackSize = 10;
          while (curr && curr["arguments"] && stack.length < maxStackSize) {
            fn = (fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON);
            args = Array.prototype.slice.call(curr["arguments"] || []);
            stack[stack.length] = fn + "(" + this.stringifyArguments(args) + ")";
            curr = curr.caller;
          }
          return stack;
        },
        stringifyArguments: function(args) {
          var arg, i, result, slice;
          result = [];
          slice = Array.prototype.slice;
          i = 0;
          while (i < args.length) {
            arg = args[i];
            if (arg === void 0) {
              result[i] = "undefined";
            } else if (arg === null) {
              result[i] = "null";
            } else if (arg.constructor) {
              if (arg.constructor === Array) {
                if (arg.length < 3) {
                  result[i] = "[" + this.stringifyArguments(arg) + "]";
                } else {
                  result[i] = "[" + this.stringifyArguments(slice.call(arg, 0, 1)) + "..." + this.stringifyArguments(slice.call(arg, -1)) + "]";
                }
              } else if (arg.constructor === Object) {
                result[i] = "#object";
              } else if (arg.constructor === Function) {
                result[i] = "#function";
              } else if (arg.constructor === String) {
                result[i] = "\"" + arg + "\"";
              } else {
                if (arg.constructor === Number) {
                  result[i] = arg;
                }
              }
            }
            ++i;
          }
          return result.join(",");
        }
      };
      if (e["arguments"] && e.stack) {
        return method.chrome(e);
      } else {
        if (e.stack) {
          return method.firefox(e);
        }
      }
      return method.other(e);
    };

    return Bebop;

  })();
  bebop = new Bebop();
  if (isBrowser) {
    bebop.connect();
    return bebop.exportGlobals();
  } else {
    exports.Bebop = Bebop;
    return exports.start = function(useRepl) {
      var repl, util;
      if (useRepl) {
        util = require("util");
        repl = require("repl");
        repl.writer = function(obj, showHidden, depth) {
          return util.inspect(obj, showHidden, depth, true);
        };
        bebop.onopen = function() {
          return repl.start("bebop> ", null, null, true);
        };
        bebop.exportGlobals();
      }
      return bebop.connect();
    };
  }
})();

/*
//@ sourceMappingURL=client.map
*/
